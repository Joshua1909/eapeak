#!/usr/bin/env python

"""
	-*- coding: utf-8 -*-
	eapscan
	
	Author: Spencer McIntyre <smcintyre [at] securestate [dot] com>
	
	Copyright 2011 SecureState
	
	This program is free software; you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation; either version 2 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
	MA 02110-1301, USA.
		
"""

__version__ = '0.0.5'
__authors__ = [ 'Spencer McIntyre', 'SecureState R&D Team' ]

import sys
try:
	from scapy.layers.l2 import eap_types as EAP_TYPES
except ImportError:
	print 'Error: Missing Scapy Libraries, Please Install Scapy From The Community Repository'
	# http://hg.secdev.org/scapy-com # needs community repository because of the extra EAP layers I added.
	print 'Error: Now Exiting...'
	sys.exit(1)

import argparse
import logging
from time import sleep
from os import getuid

from eapeak.common import checkInterface
from eapeak.parse import EapeakParsingEngine
from eapeak.networks import WirelessNetwork
from eapeak.inject import WirelessStateMachine, WirelessStateMachineEAP
from ipfunc import sanitizeMAC, getHwAddr

from scapy.config import conf
# these edit the load_layers configuration to keep layers we don't need out and consume less memory
not_needed_layers = [	'bluetooth', 'cdp', 'dhcp', 'dhcp6', 'dns', 'eigrp', 'hsrp', 'inet6', 'ir',
						'isakmp', 'l2tp', 'llmnr', 'mgcp', 'mobileip', 'netbios', 'netflow', 'ntp',
						'ospf', 'ppi_cace', 'ppi_geotag', 'ppi', 'ppp', 'rip', 'rtp', 'sctp', 'sebek',
						'skinny', 'smb', 'snmp', 'tftp', 'vrrp', 'x509'
					]

for layer in not_needed_layers:
	conf.load_layers.remove(layer)
del layer, not_needed_layers
conf.ipv6_enabled = False

from scapy.volatile import RandMAC
EAP_TYPES[0] = 'NONE'
scapy_runtime_log = logging.getLogger("scapy.runtime")
scapy_runtime_log.setLevel(logging.CRITICAL)

GOOD = '\033[1;32m[+]\033[1;m '
STATUS = '\033[1;34m[*]\033[1;m '
ERROR = '\033[1;31m[-]\033[1;m '
ERROR_SLEEP_TIME = 1.5	# time to wait between error and retry

def eap_scan(interface, bssid, essid, check_range):
	valid_eap_types = []
	try:
		status_str = ''
		for eaptype in check_range:
			sys.stdout.write((' ' * len(status_str)) + '\r')
			sys.stdout.flush()
			if eaptype in EAP_TYPES:
				status_str = STATUS + 'Checking EAP Type: ' + EAP_TYPES[eaptype] + '\r'
			else:
				status_str = STATUS + 'Checking EAP Type: ' + str(eaptype) + '\r'
			sys.stdout.write(status_str)
			sys.stdout.flush()
			tries = 0
			while tries < 5:
				statemachine = WirelessStateMachineEAP(interface, bssid, RandMAC('00:*:*:*:*:*').__str__(), bssid)
				errCode = statemachine.connect(essid)
				if errCode:
					sleep(ERROR_SLEEP_TIME)
					tries += 1
					continue # try same
				errCode = statemachine.check_eap_type(eaptype)
				if errCode == 0:
					sys.stdout.write((' ' * len(status_str)) + '\r')
					sys.stdout.flush()
					if eaptype in EAP_TYPES:
						status_str = GOOD + 'EAP Type: ' + EAP_TYPES[eaptype] + ' Supported\n'
					else:
						status_str = GOOD + 'EAP Type: ' + str(eaptype) + ' Supported\n'
					sys.stdout.write(status_str)
					sys.stdout.flush()
					valid_eap_types.append(eaptype)
					tries = 0
					statemachine.close()
					break # try next
				elif errCode == 1:
					tries = 0
					statemachine.close()
					break # try next
				elif errCode == 2:
					sleep(ERROR_SLEEP_TIME)
					tries += 1
					statemachine.close()
					continue # try same
			if tries == 0:
				continue
			sys.stdout.write((' ' * len(status_str)) + '\r')
			sys.stdout.flush()
			if eaptype in EAP_TYPES:
				status_str = ERROR + 'EAP Type: ' + EAP_TYPES[eaptype] + ' Could Not Be Determined\n'
			else:
				status_str = ERROR + 'EAP Type: ' + str(eaptype) + ' Could Not Be Determined\n'
			sys.stdout.write(status_str)	# haha STD
			sys.stdout.flush()
	except KeyboardInterrupt:
		print '\n' + STATUS + 'Caught Ctrl+C'
		return valid_eap_types
	sys.stdout.write(' ' * len(status_str) + '\n') # overwrite checking stuff
	sys.stdout.flush()
	return valid_eap_types

def check_ap_connection(interface, bssid, essid, quite = True):
	if not quite:
		sys.stdout.write(STATUS + 'Checking Connection To AP')
		sys.stdout.flush()
	tries = 0
	try:
		while tries < 3:
			statemachine = WirelessStateMachine(interface, bssid, RandMAC('00:*:*:*:*:*').__str__(), bssid)
			errCode = statemachine.connect(essid)
			if errCode:
				sleep(ERROR_SLEEP_TIME)
				if not quite:
					sys.stdout.write('.')
					sys.stdout.flush()
				tries += 1
				continue
			statemachine.close()
			tries = 0
			break
	except KeyboardInterrupt:
		print '\n' + STATUS + 'Caught Ctrl+C'
		return False
	if tries != 0:
		if not quite:
			sys.stdout.write('\n' + ERROR + 'Connection Attempts Failed\n')
			sys.stdout.flush()
		return False
	elif not quite:
		sys.stdout.write(' OK!\n')
		sys.stdout.flush()
	return True

def main():
	parser = argparse.ArgumentParser(description = 'EAPScan: Actively Enumerate 802.1x Wireless Networks', conflict_handler='resolve')
	parser.add_argument('-e', '--essid', dest = 'essid', action = 'store', required = True, default = '', help = 'target ESSID')
	parser.add_argument('-b', '--bssid', dest = 'bssid', action = 'store', required = True, default = '', help = 'target BSSID')
	parser.add_argument('-i', '--iface', dest = 'iface', action = 'store', required = True, help = 'interface to use when capturing live')
	parser.add_argument('-v', '--version', action = 'version', version = parser.prog + ' Version: ' + __version__)
	parser.add_argument('--all', dest = 'scan_all', action = 'store_true', default = False, help = 'scan all EAP types (4-253)')
	parser.add_argument('--types', dest = 'eap_types', nargs = '*', action = 'store', default = [], help = 'list of specific EAP types to try')
	parser.add_argument('--xml', dest = 'save_xml', action = 'store_true', default = False, help = 'export data to xml')
	options = parser.parse_args()

	if getuid():
		print ERROR + 'Must Be Root To Inject Packets, Now Exiting...'
		return 2

	if not sanitizeMAC(options.bssid):
		print ERROR + 'Invalid MAC Address, Now Exiting...'
		return 3

	if not checkInterface(options.iface) in [ 0, 1 ]:
		print ERROR + 'Invalid Interface, Now Exiting...'
		return 4

	# Build the list of EAP types that we're scanning for
	if options.scan_all:
		print STATUS + 'Scanning All EAP Types, This Could Take A While...'
		check_range = range(4, 254)
	elif options.eap_types:
		check_range = []
		
	
		for eaptype in options.eap_types:
			if eaptype.upper() in EAP_TYPES.values():
				eaptype = str(EAP_TYPES.keys()[ EAP_TYPES.values().index(eaptype.upper()) ])
			if eaptype.isdigit() and 3 < int(eaptype) < 254:
				check_range.append(int(eaptype))
			else:
				print ERROR + 'Invalid EAP Type: ' + eaptype
		if len(check_range) == 0:
			print ERROR + 'No Usable EAP Types (4-253), Now Exiting...'
			return 5
	else:
		check_range = EAP_TYPES.keys()
		check_range.sort()
		check_range = check_range[4:]

	# Make sure the AP is responding
	if not check_ap_connection(options.iface, options.bssid, options.essid, False):
		print ERROR + 'Now Exiting...'
		return 0

	# Scan for the eap types
	valid_eap_types = eap_scan(options.iface, options.bssid, options.essid, check_range)

	if options.save_xml:
		eapeakParser = EapeakParsingEngine()
		newNetwork = WirelessNetwork(options.essid, options.bssid)
		[ newNetwork.addEapType(x) for x in valid_eap_types ]	# Python black magic trickery
		eapeakParser.KnownNetworks[options.essid] = newNetwork
		eapeakParser.BSSIDToSSIDMap[options.bssid] = options.essid
		eapeakParser.exportXML()

	return 0	

if __name__ == '__main__':
	main()
